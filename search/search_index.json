{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CEMU Documentation","text":""},{"location":"#introduction","title":"Introduction","text":"<p>CEMU is a full system emulator framework designed to easily change all aspects in a simple CPU and SoC for education and research purposes.</p> <p>You can use CEMU for:</p> <ul> <li>Differential Test with CPU RTL with SoC-simulator</li> <li>Develop new ISA-level extension</li> <li>Define your own performance counter and tracer for software workload exploration</li> <li>Develop a simple CPU and bus performance model</li> </ul>"},{"location":"#isa-support","title":"ISA Support","text":"<ul> <li> <p>RISC-V</p> <ul> <li>rv64imac (rv64gc without FPU)</li> <li>Three privilege levels of  Machine, Supervisor, and User</li> <li>SV39 Virtual Memory with TLB emulation</li> </ul> </li> <li> <p>MIPS32</p> <ul> <li>MIPS32 Release 1 without Branch-Likely</li> <li>TLB based MMU Support, 4KB Page Only</li> </ul> </li> <li> <p>LoongArch32 (Reduced)</p> <ul> <li>Support LoongArch32(Reduced) instruction set, except FP instructions</li> </ul> </li> </ul>"},{"location":"#device-support","title":"Device Support","text":"<ul> <li>UART8250</li> <li>Xilinx UARTLite</li> <li>Xilinx AXI EthernetLite (Without ping-pong buffer and MDIO)</li> <li>RISC-V CLINT</li> <li>RISC-V PLIC</li> </ul>"},{"location":"#some-talks-about-cemu","title":"Some talks about CEMU","text":"<ul> <li>\u91cd\u5e86\u5927\u5b66\u9648\u6cf1\u5b87\uff1aSoC-Simulator\u2014\u2014\u4e00\u4e2a\u7b80\u5355\u6613\u7528\u7684\u8f6f\u4ef6\u5b9a\u4e49AXI Slave\u8bbe\u5907\u6846\u67b6</li> <li>2023\u5e74\u201c\u9f99\u82af\u676f\u201d\u7b2c\u4e8c\u6b21\u57f9\u8bad</li> </ul>"},{"location":"la32r/setup/","title":"La32r Setup","text":""},{"location":"la32r/setup/#toolchains","title":"Toolchains","text":"<p>We recommend to use chenyy/la32r-env for uCore or Linux build.</p> <pre><code>$ docker pull chenyy/la32r-env:latest\n</code></pre> <p>Then we can launch the container based on the image.</p> <pre><code>$ docker run -dit \\\n--name la32r-docker \\\n--net=host \\\n-e LANG=en_US.UTF-8 \\\n-e LANGUAGE=en_US.UTF-8 \\\n-e LC_ALL=en_US.UTF-8 \\\nchenyy/la32r-env:latest\n</code></pre> <p>Now you can enter the container and use la32r toolchains.</p> <pre><code>$ docker exec -it la32r-docker /bin/zsh\n</code></pre>"},{"location":"la32r/setup/#ucore-boot","title":"uCore boot","text":"<p>First, we need to build uCore &amp; CEMU.</p> <pre><code>$ git clone https://github.com/cyyself/ucore-loongarch32.git\n$ pushd ucore-loongarch32\n$ make\n$ loongarch32r-linux-gnusf-objcopy -O binary obj/ucore-kernel-initrd obj/ucore-kernel-initrd.bin\n$ popd\n$ git clone https://github.com/cyyself/cemu.git\n$ cd cemu\n</code></pre> <p>Save the following content to <code>src/main.cpp</code></p> src/main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;termios.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;thread&gt;\n#include &lt;signal.h&gt;\n\n#include \"device/nscscc_confreg.hpp\"\n#include \"device/uart8250.hpp\"\n#include \"memory/memory_bus.hpp\"\n#include \"memory/ram.hpp\"\n#include \"core/la32r/la32r_core.hpp\"\n\nvoid uart_input(uart8250 &amp;uart) {\ntermios tmp;\ntcgetattr(STDIN_FILENO, &amp;tmp);\ntmp.c_lflag &amp;= (~ICANON &amp; ~ECHO);\ntcsetattr(STDIN_FILENO, TCSANOW, &amp;tmp);\nwhile (true) {\nchar c = getchar();\nif (c == 10) c = 13; // convert lf to cr\nuart.putc(c);\n}\n}\n\nbool send_ctrl_c;\n\nvoid sigint_handler(int x) {\nstatic time_t last_time;\nif (time(NULL) - last_time &lt; 1) exit(0);\nlast_time = time(NULL);\nsend_ctrl_c = true;\n}\n\nint main(int argc, char **argv) {\nsignal(SIGINT, sigint_handler);\n\nmemory_bus cemu_mmio;\n\nram cemu_memory(128 * 1024 * 1024);\ncemu_memory.load_binary(0x000000, \"../ucore-loongarch32/obj/ucore-kernel-initrd.bin\");\nassert(cemu_mmio.add_dev(0, 128 * 1024 * 1024, &amp;cemu_memory));\n\nuart8250 uart;\nstd::thread *uart_input_thread = new std::thread(uart_input, std::ref(uart));\nassert(cemu_mmio.add_dev(0x1fe001e0, 0x10, &amp;uart));\n\nla32r_core&lt;32&gt; core(0, cemu_mmio, false);\ncore.csr_cfg(0x180, 0xa0000011u);\ncore.csr_cfg(0x181, 0x80000001u);\ncore.csr_cfg(0x0, 0xb0);\ncore.jump(0xa0000000u);\nwhile (true) {\ncore.step(uart.irq() &lt;&lt; 1);\nwhile (uart.exist_tx()) {\nchar c = uart.getc();\nif (c != '\\r') {\nputchar(c);\nfflush(stdout);\n}\n}\nif (send_ctrl_c) {\nuart.putc(3);\nsend_ctrl_c = false;\n}\n}\nreturn 0;\n}\n</code></pre> <p>Then build and run cemu.</p> <pre><code>$ make  # in cemu project folder\n$ ./cemu\n++setup timer interrupts\n(THU.CST) os is loading ...\n\nSpecial kernel symbols:\n  entry  0xA0000120 (phys)\n  etext 0xA0022000 (phys)\n  edata 0xA025CEA0 (phys)\n  end   0xA0260180 (phys)\nKernel executable memory footprint: 2297KB\nmemory management: default_pmm_manager\nmemory map:\n    [A0000000, A2000000]\n\nfreemem start at: A02A1000\nfree pages: 00001D5F\n## 00000020\ncheck_alloc_page() succeeded!\ncheck_pgdir() succeeded!\ncheck_boot_pgdir() succeeded!\ncheck_slab() succeeded!\nkmalloc_init() succeeded!\ncheck_vma_struct() succeeded!\ncheck_pgfault() succeeded!\ncheck_vmm() succeeded.\nsched class: stride_scheduler\nproc_init succeeded\nInitrd: 0xa00601c0 - 0xa02541bf, size: 0x001f4000, magic: 0x2f8dbe2a\nramdisk_init(): initrd found, magic: 0x2f8dbe2a, 0x00000fa0 secs\nsfs: mount: 'simple file system' (352/148/500)\nvfs: mount disk0.\nkernel_execve: pid = 2, name = \"sh\".\nuser sh is running!!!\n$\n</code></pre>"},{"location":"la32r/setup/#linux-boot","title":"Linux boot","text":""},{"location":"la32r/setup/#download-prebuilt-busybox-ramdisk","title":"Download Prebuilt Busybox Ramdisk","text":"<p>Use the following command to download prebuilt busybox ramdisk.</p> <pre><code>$ mkdir -p initrd_d\n$ wget -qO- https://gitee.com/loongson-edu/la32r-Linux/releases/download/v0.2/initrd_d.tar.gz | tar -xv -C initrd_d --strip-components 1\n</code></pre>"},{"location":"la32r/setup/#build-linux-kernel","title":"Build Linux Kernel","text":"<p>First, we need to clone la32r-Linux repository.</p> <pre><code>$ git clone --depth 1 https://gitee.com/loongson-edu/la32r-Linux.git\n$ pushd la32r-Linux\n</code></pre> <p>Save the following content to file <code>cemu.patch</code>.</p> cemu.patch<pre><code>From 78c2470efcd6b285e3d0e73893d53b32c51b809b Mon Sep 17 00:00:00 2001\nFrom: coekjan &lt;cn_yzr@qq.com&gt;\nDate: Fri, 12 May 2023 23:44:37 +0800\nSubject: [PATCH] Patch For CEMU\n\n---\n.../boot/dts/loongson/loongson32_ls.dts       | 43 -------------------\n arch/loongarch/include/asm/time.h             |  2 +-\n la_build.sh                                   |  5 ++-\n 3 files changed, 4 insertions(+), 46 deletions(-)\n\ndiff --git a/arch/loongarch/boot/dts/loongson/loongson32_ls.dts b/arch/loongarch/boot/dts/loongson/loongson32_ls.dts\nindex f33c0ce23..947605d40 100644\n--- a/arch/loongarch/boot/dts/loongson/loongson32_ls.dts\n+++ b/arch/loongarch/boot/dts/loongson/loongson32_ls.dts\n@@ -56,49 +56,6 @@ cpu_uart0: serial@0x1fe001e0 {\n                        no-loopback-test;\n                 };\n\n-        gmac0: dmfe@0x1ff00000{\n-                        compatible = \"dmfe\";\n-                        reg = &lt;0x1ff00000 0x10000&gt;;\n-                        interrupt-parent = &lt;&amp;cpuic&gt;;\n-                        interrupts = &lt;3&gt;;\n-                        interrupt-names = \"macirq\";\n-                        mac-address = [ 64 48 48 48 48 60 ];/* [&gt;mac 64:48:48:48:48:60 &lt;]*/\n-                        phy-mode = \"rgmii\";\n-                        bus_id = &lt;0x0&gt;;\n-                        phy_addr = &lt;0xffffffff&gt;;\n-                        dma-mask = &lt;0xffffffff 0xffffffff&gt;;\n-                };\n-#if 0\n-            ahci@0x1fe30000{\n-                compatible = \"snps,spear-ahci\";\n-                reg = &lt;0x1fe30000 0x10000&gt;;\n-                interrupt-parent = &lt;&amp;cpuic&gt;;\n-                interrupts = &lt;4&gt;;\n-                dma-mask = &lt;0x0 0xffffffff&gt;;\n-            };\n-#endif\n-\n-        nand@0x1fe78000{\n-             #address-cells = &lt;1&gt;;\n-             #size-cells = &lt;1&gt;;\n-             compatible = \"ls1a-nand\";\n-             reg = &lt;0x1fe78000 0x4000\n-                 0x1fd01160 0x0&gt;;\n-             interrupt-parent = &lt;&amp;cpuic&gt;;\n-             interrupts = &lt;4&gt;;\n-             interrupt-names = \"nand_irq\";\n-\n-             number-of-parts = &lt;0x2&gt;;\n-             partition@0 {\n-                 label = \"kernel_partition\";\n-                 reg = &lt;0x0000000 0x01400000&gt;;\n-             };\n-\n-             partition@0x01400000 {\n-                 label = \"os_partition\";\n-                 reg = &lt;0x01400000 0x0&gt;;\n-             };\n-         };\n\n    };\n };\ndiff --git a/arch/loongarch/include/asm/time.h b/arch/loongarch/include/asm/time.h\nindex d4cc3876d..1a348b561 100644\n--- a/arch/loongarch/include/asm/time.h\n+++ b/arch/loongarch/include/asm/time.h\n@@ -41,7 +41,7 @@ static inline unsigned int calc_const_freq(void)\n#define LOONGARCH32_FREQ_REG 0x9fd0f030\n static inline unsigned int calc_const_freq(void)\n {\n-    unsigned int freq = *(int *)LOONGARCH32_FREQ_REG;\n+    unsigned int freq = 33333333;\n   return freq;\n }\n #endif\ndiff --git a/la_build.sh b/la_build.sh\nindex 7ce234a08..b32815540 100755\n--- a/la_build.sh\n+++ b/la_build.sh\n@@ -1,6 +1,6 @@\n#!/bin/bash\n\n-export CROSS_COMPILE=~/install-32-glibc-loongarch-novec-reduce-linux-5-14/bin/loongarch32-linux-gnu-\n+export CROSS_COMPILE=loongarch32r-linux-gnusf-\nexport ARCH=loongarch\n OUT=la_build\n\n@@ -9,7 +9,8 @@ if [ ! -d la_build ] ;then\n    make la32_defconfig O=${OUT}\n fi\n\n+sed -i \"/^CONFIG_INITRAMFS_SOURCE/s,=.*$,=\\\"$(realpath ../initrd_d)\\\",\" ./la_build/.config\n+\necho \"----------------output ${OUT}----------------\"\n\n-make menuconfig O=${OUT}\nmake vmlinux -j  O=${OUT} 2&gt;&amp;1 | tee -a build_error.log\n-- \n2.40.1\n</code></pre> <p>Then, apply the patch and build kernel.</p> <pre><code>$ git apply cemu.patch\n$ ./la_build.sh\n$ loongarch32r-linux-gnusf-objcopy -O binary la_build/vmlinux la_build/vmlinux.bin\n$ popd\n</code></pre>"},{"location":"la32r/setup/#build-run-cemu","title":"Build &amp; RUN CEMU","text":"<p>Clone CEMU repository.</p> <pre><code>$ git clone https://github.com/cyyself/cemu.git\n$ cd cemu\n</code></pre> <p>Fetch <code>init_5f.txt</code> from chiplab.</p> <pre><code>$ wget -q https://gitee.com/loongson-edu/chiplab/raw/chiplab_diff/software/linux/init_5f.txt\n</code></pre> <p>Save the following content to <code>src/main.cpp</code></p> src/main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;termios.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;thread&gt;\n#include &lt;signal.h&gt;\n\n#include \"device/nscscc_confreg.hpp\"\n#include \"device/uart8250.hpp\"\n#include \"memory/memory_bus.hpp\"\n#include \"memory/ram.hpp\"\n#include \"core/la32r/la32r_core.hpp\"\n\nvoid uart_input(uart8250 &amp;uart) {\ntermios tmp;\ntcgetattr(STDIN_FILENO, &amp;tmp);\ntmp.c_lflag &amp;= (~ICANON &amp; ~ECHO);\ntcsetattr(STDIN_FILENO, TCSANOW, &amp;tmp);\nwhile (true) {\nchar c = getchar();\nif (c == 10) c = 13; // convert lf to cr\nuart.putc(c);\n}\n}\n\nbool send_ctrl_c;\n\nvoid sigint_handler(int x) {\nstatic time_t last_time;\nif (time(NULL) - last_time &lt; 1) exit(0);\nlast_time = time(NULL);\nsend_ctrl_c = true;\n}\n\nint main(int argc, char **argv) {\nsignal(SIGINT, sigint_handler);\n\nmemory_bus cemu_mmio;\n\nram cemu_memory(128 * 1024 * 1024);\ncemu_memory.load_binary(0x300000, \"../la32r-Linux/la_build/vmlinux.bin\");\ncemu_memory.load_text(0x5f00000, \"./init_5f.txt\");\nassert(cemu_mmio.add_dev(0, 128 * 1024 * 1024, &amp;cemu_memory));\n\nuart8250 uart;\nstd::thread *uart_input_thread = new std::thread(uart_input, std::ref(uart));\nassert(cemu_mmio.add_dev(0x1fe001e0, 0x10, &amp;uart));\n\nla32r_core&lt;32&gt; core(0, cemu_mmio, false);\ncore.csr_cfg(0x180, 0xa0000001u);\ncore.csr_cfg(0x181, 0x00000001u);\ncore.csr_cfg(0x0, 0x10);\ncore.reg_cfg(4, 2);\ncore.reg_cfg(5, 0xa5f00000u);\ncore.reg_cfg(6, 0xa5f00080u);\ncore.jump(0xa07c5c28u);\n\nwhile (true) {\ncore.step(uart.irq() &lt;&lt; 1);\nwhile (uart.exist_tx()) {\nchar c = uart.getc();\nif (c != '\\r') {\nputchar(c);\nfflush(stdout);\n}\n}\nif (send_ctrl_c) {\nuart.putc(3);\nsend_ctrl_c = false;\n}\n}\nreturn 0;\n}\n</code></pre> <p>Finally, build and run CEMU.</p> <pre><code>$ make  # in cemu project folder\n$ ./cemu\n[    0.000000] Linux version 5.14.0-rc2-gbb6b2ca56ade-dirty (@Inspiron-Manjaro) (loongarch32r-linux-gnusf-gcc (GCC) 8.3.0, GNU ld (GNU Binutils) 2.31.1.20190122) #3 PREEMPT Fri May 12 16:08:23 UTC 2023\n[    0.000000] Standard 32-bit Loongson Processor probed\n[    0.000000] the link is empty!\n[    0.000000] Scan bootparam failed\n[    0.000000] printk: bootconsole [early0] enabled\n[    0.000000] initrd start &lt; PAGE_OFFSET\n[    0.000000] Can't find EFI system table.\n[    0.000000] start_pfn=0x0, end_pfn=0x8000, num_physpages:0x8000\n[    0.000000] The BIOS Version: (null)\n[    0.000000] Initrd not found or empty - disabling initrd\n[    0.000000] CPU0 revision is: 00004200 (Loongson-32bit)\n[    0.000000] Primary instruction cache 8kB, 2-way, VIPT, linesize 16 bytes.\n[    0.000000] Primary data cache 8kB, 2-way, VIPT, no aliases, linesize 16 bytes\n[    0.000000] Zone ranges:\n[    0.000000]   DMA32    [mem 0x0000000000000000-0x00000000ffffffff]\n[    0.000000]   Normal   empty\n[    0.000000] Movable zone start for each node\n[    0.000000] Early memory node ranges\n[    0.000000]   node   0: [mem 0x0000000000000000-0x0000000007ffffff]\n[    0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x0000000007ffffff]\n[    0.000000] eentry = 0xa0210000,tlbrentry = 0xa0201000\n[    0.000000] pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768\n[    0.000000] pcpu-alloc: [0] 0 \n[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 32480\n[    0.000000] Kernel command line: =/init loglevel=8\n[    0.000000] Dentry cache hash table entries: 16384 (order: 4, 65536 bytes, linear)\n[    0.000000] Inode-cache hash table entries: 8192 (order: 3, 32768 bytes, linear)\n[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off\n[    0.000000] Memory: 117736K/131072K available (4926K kernel code, 1114K rwdata, 944K rodata, 2480K init, 473K bss, 13336K reserved, 0K cma-reserved)\n[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\n[    0.000000] rcu: Preemptible hierarchical RCU implementation.\n[    0.000000] rcu:     RCU event tracing is enabled.\n[    0.000000]  Trampoline variant of Tasks RCU enabled.\n[    0.000000]  Tracing variant of Tasks RCU enabled.\n[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.\n[    0.000000] NR_IRQS: 320\n[    0.000000] Constant clock event device register\n[    0.000000] clocksource: Constant: mask: 0xffffffffffffffff max_cycles: 0x7b00c4bad, max_idle_ns: 440795202744 ns\n[    0.000000] Constant clock source device register\n[    0.004000] Console: colour dummy device 80x25\n[    0.004000] Calibrating delay loop (skipped), value calculated using timer frequency.. 66.66 BogoMIPS (lpj=133333)\n[    0.004000] pid_max: default: 32768 minimum: 301\n[    0.008000] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.008000] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.036000] rcu: Hierarchical SRCU implementation.\n[    0.040000] devtmpfs: initialized\n[    0.052000] random: get_random_u32 called from bucket_table_alloc.isra.34+0x68/0x1d8 with crng_init=0\n[    0.056000] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns\n[    0.056000] futex hash table entries: 256 (order: -1, 3072 bytes, linear)\n[    0.064000] NET: Registered PF_NETLINK/PF_ROUTE protocol family\n[    0.248000] pps_core: LinuxPPS API ver. 1 registered\n[    0.248000] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;\n[    0.264000] clocksource: Switched to clocksource Constant\n[    0.268000] FS-Cache: Loaded\n[    0.384000] NET: Registered PF_INET protocol family\n[    0.384000] IP idents hash table entries: 2048 (order: 2, 16384 bytes, linear)\n[    0.400000] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes, linear)\n[    0.400000] TCP established hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.400000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.400000] TCP: Hash tables configured (established 1024 bind 1024)\n[    0.400000] UDP hash table entries: 256 (order: 0, 4096 bytes, linear)\n[    0.400000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes, linear)\n[    0.404000] NET: Registered PF_UNIX/PF_LOCAL protocol family\n[    0.428000] workingset: timestamp_bits=14 max_order=15 bucket_order=1\n[    0.620000] IPMI message handler: version 39.2\n[    0.620000] ipmi device interface\n[    0.620000] ipmi_si: IPMI System Interface driver\n[    0.628000] ipmi_si: Unable to find any System Interface(s)\n[    0.732000] Serial: 8250/16550 driver, 16 ports, IRQ sharing enabled\n[    0.816000] printk: console [ttyS0] disabled\n[    0.816000] 1fe001e0.serial: ttyS0 at MMIO 0x1fe001e0 (irq = 18, base_baud = 2062500) is a 16550A\n[    0.816000] printk: console [ttyS0] enabled\n[    0.816000] printk: console [ttyS0] enabled\n[    0.816000] printk: bootconsole [early0] disabled\n[    0.816000] printk: bootconsole [early0] disabled\n[    0.840000] ls1a-nand driver initializing\n[    0.840000] ITC MAC 10/100M Fast Ethernet Adapter driver 1.0 init\n[    0.864000] libphy: Fixed MDIO Bus: probed\n[    0.872000] mousedev: PS/2 mouse device common for all mice\n[    0.888000] IR MCE Keyboard/mouse protocol handler initialized\n[    0.888000] hid: raw HID events driver (C) Jiri Kosina\n[    0.920000] NET: Registered PF_INET6 protocol family\n[    0.948000] Segment Routing with IPv6\n[    0.948000] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver\n[    1.016000] random: fast init done\n[    5.424000] Warning: unable to open an initial console.\n[    5.752000] Freeing unused kernel image (initmem) memory: 2480K\n[    5.752000] This architecture does not have kernel memory protection.\n[    5.752000] Run /init as init process\n[    5.752000]   with arguments:\n[    5.752000]     /init\n[    5.752000]   with environment:\n[    5.752000]     HOME=/\n[    5.752000]     TERM=linux\n\nProcessing /etc/profile... Done\n\n/ # \n</code></pre>"},{"location":"mips/difftest-nscscc/","title":"Differential Test in NSCSCC","text":"<p>The CPU design track of the National Student Computer System Capability Challenge (NSCSCC), also known as the \"Loongson Cup\" (\u201c\u9f99\u82af\u676f\u201d in Chinese) is a competition for college students in China.</p> <p>We can use CEMU with SoC-Simulator to help the competitors in various way, such as:</p> <ul> <li>Much faster simulation speed compared to Vivado</li> <li>Differential Test when running Linux / uCore</li> <li>Add some performance counter in software to profile the performance</li> </ul>"},{"location":"mips/difftest-nscscc/#prerequisites","title":"Prerequisites","text":"<p>Verilator &gt;= v4.2</p> <p>Warning</p> <p>Note for Debian/Ubuntu Users: If your Ubuntu version &lt; 23.04(lunar) or Debian version &lt; 12(bookworm), you can NOT install verilator directly through <code>apt install verilator</code>, the verilator in offcial repo of your distro is too old that can not build soc-simulator.</p>"},{"location":"mips/difftest-nscscc/#simple-usage-for-function-test-and-performance-test","title":"Simple usage for function test and performance test","text":"<p>If you only need to speed up NSCSCC function test and performance test using Verilator instead of Vivado, you can use the Lab Package from Chongqing University Computer Organization Course - Integrated Hardware Design. </p> <p>And we also have the tutorial video on bilibili.</p> <p>Both the README in the package and the video are in Chinese.</p> <p>Note</p> <p>We have modified the function test in the lab package as we use 7a100t FPGA(Diligent Nexys4 DDR) for the Lab course instead of 7a200t in NSCSCC, and the BRAM resource is very limited in 7a100t, so the function test in the CQU lab package will be slightly different on memory layout from the function test in nscscc-group package.</p> <p>You can replace the files in the <code>vivado/func_test_v0.01/soft/</code> in our package if you want to test your CPU RTL with the original function test from nscscc, which will not affect the verilator framework.</p>"},{"location":"mips/difftest-nscscc/#how-does-cemu-and-soc-simulator-dial-with-different-counter-value-in-differential-performance-test","title":"How does CEMU and SoC-Simulator dial with different counter value in differential performance test?","text":"<p>The performance test will read 2 performance counter:</p> <ul> <li>CP0.count</li> <li>CONFREG.timer</li> </ul> <p>We have <code>debug_wb_is_timer</code> flag in CEMU, it will be reset to false at every step one instruction, then if the instruction load the CONFREG.timer in kseg1 or executed mfc0 to load CP0.counter, this flag will set to true to tell the diffential test function that the value may different between RTL and CEMU, so the differetial test function will call CEMU to update the GPR commit value from CPU RTL and thus we will have the same value.</p> Code <pre><code>diff --git a/src/core/mips/mips_core.hpp b/src/core/mips/mips_core.hpp\nindex 4321630..bea2270 100644\n--- a/src/core/mips/mips_core.hpp\n+++ b/src/core/mips/mips_core.hpp\n@@ -46,6 +46,7 @@ public:\n       debug_wb_wen = 0;\n        debug_wb_wnum = 0;\n        debug_wb_wdata = 0;\n+        debug_wb_is_timer = 0;\n       j_cnt = 0;\n        forward_branch = 0;\n        forward_branch_taken = 0;\n@@ -76,6 +77,7 @@ public:\n   uint8_t  debug_wb_wen;\n    uint8_t  debug_wb_wnum;\n    uint32_t debug_wb_wdata;\n+    bool     debug_wb_is_timer;\n   std::queue &lt;uint32_t&gt; pc_trace;\n    std::set &lt;uint32_t&gt; cache_op;\n    // TODO: trace with exceptions (add exception signal at commit stage is need)\n@@ -91,6 +93,7 @@ private:\n       debug_wb_wen = 0;\n        debug_wb_wnum = 0;\n        debug_wb_wdata = 0;\n+        debug_wb_is_timer = false;\n       mips_instr instr;\n        mips32_exccode if_exc = EXC_OK;\n        pc_trace.push(pc);\n@@ -727,6 +730,7 @@ private:\n               // LW\n                uint32_t vaddr = GPR[instr.i_type.rs] + instr.i_type.imm;\n                uint32_t buf;\n+                if (vaddr == 0xbfafe000u) debug_wb_is_timer = true; // for difftest\n               mips32_exccode stat = mmu.va_read(vaddr, 4, (unsigned char*)&amp;buf, cp0.get_ksu(), cp0.get_asid(), tlb_invalid);\n                if (stat != EXC_OK) cp0.raise_trap(stat, vaddr, tlb_invalid);\n                else set_GPR(instr.i_type.rt, buf);\n@@ -870,6 +874,7 @@ private:\n                   switch (instr.r_type.rs) {\n                        case RS_MFC0: {\n                            // MFC0\n+                            if (instr.r_type.rd == RD_COUNT &amp;&amp; (instr.r_type.funct &amp; 0b111) == 0) debug_wb_is_timer = true; // for difftest\n                           set_GPR(instr.r_type.rt, cp0.mfc0(instr.r_type.rd, instr.r_type.funct&amp;0b111));\n                            break;\n                        }\n@@ -927,6 +932,7 @@ private:\n               // LL as LW\n                uint32_t vaddr = GPR[instr.i_type.rs] + instr.i_type.imm;\n                uint32_t buf;\n+                if (vaddr == 0xbfafe000u) debug_wb_is_timer = true; // for difftest\n               mips32_exccode stat = mmu.va_read(vaddr, 4, (unsigned char*)&amp;buf, cp0.get_ksu(), cp0.get_asid(), tlb_invalid);\n                if (stat != EXC_OK) cp0.raise_trap(stat, vaddr, tlb_invalid);\n                else set_GPR(instr.i_type.rt, buf);\n</code></pre>"},{"location":"mips/difftest-nscscc/#differential-test-when-running-operating-systems","title":"Differential Test when running operating systems","text":""},{"location":"mips/difftest-nscscc/#adding-debug-signals","title":"Adding debug signals","text":"<p>Originally, NSCSCC provide the following debug signals:</p> <pre><code>output [31:0]   debug_wb_pc,\noutput [ 3:0]   debug_wb_rf_wen,\noutput [ 4:0]   debug_wb_rf_wnum,\noutput [31:0]   debug_wb_rf_wdata,\n</code></pre> Note <p>With the help of the open_trace flag in NSCSCC confreg to turn off the trace when the CPU behavior is different with golden trace but acceptable (such as CP0.status.BD in n77 software interrupt test), it will be easy to allow different behavior if the different GPR write data will only be propagated in a very limited range in control flow.</p> <p>However, the operating systems are much more complex than the function test because they will have timer interrupts. Although the emulator should know the accurate cycle to generate an interrupt, the CPU may not interrupt immediately.</p> <p>For example, CQU Dual Issue Machine is a dual-issue five-stage pipeline processor which binds interrupts to a specific PC at the 2nd stage(decode). However, the interrupt will raise at the 4th stage(memory), so it will have at least 2 more instruction being executed after the interrupt signal fired, thus will have different behavior between emulator and CPU RTL.</p> <p>This behavior is called asynchronous interrupt, which is allowed in almost every ISA.</p> <p>Moreover, MIPS introduces TLBWR (TLB write random) instruction, and which entry in TLB to write depends on the value of CP0.random. However, the differential test can not directly know the value in CP0.random and when the CP0.random value is taken for TLBWR instruction though this behavior is CPU implementation dependent. Thus will have different TLB states between the emulator and CPU RTL.</p> <p>Here comes a challenge: How to differential test when interrupts are on and trace the TLB random write?</p> <p>To solve the interrupt synchonize problem, SoC-Simulator adds two additional debug signals of a specific PC in insturction commit trace, which are CP0.cause value and whether the interrupt fired. </p> <pre><code>output [31:0]   debug_cp0_cause, // CP0.cause\noutput          debug_int // whether the interrupt fired\n</code></pre> <p>In this case, differential test can be implemented in the following way (pseudocode):</p> <pre><code>while (1) { // main loop\nRTL.step_one_instruction();\nCEMU.import_diff_test_info(RTL.debug_cp0_cause, RTL.debug_int);\n// CEMU will take the cp0 cause value to update its CSR.\n// And it will only raise interrupt when RTL.debug_int is 1.\nCEMU.step_one_instructino();\ncompare_commit_result(RTL, CEMU); // check RTL behavior\n}\n</code></pre> <p>Since it will only have unpredictable behavior in TLBWR among all TLB behavior, what emulator should do is simply taken the CP0.random value used for executing TLBWR.</p> <pre><code>output [31:0] debug_cp0_ramdom\n</code></pre> <p>SoC-Simulator extended the debug signals to:</p> <pre><code>// nscscc debug interface\noutput [31:0]   debug_wb_pc,\noutput [ 3:0]   debug_wb_rf_wen,\noutput [ 4:0]   debug_wb_rf_wnum,\noutput [31:0]   debug_wb_rf_wdata,\n// soc-simulator + cemu debug interface\noutput [31:0]   debug_cp0_ramdom,// cp0_random used in TLBWR\noutput [31:0]   debug_cp0_cause, // cp0_cause for rising interrupts and mfc0\noutput          debug_int,       output          debug_commit\n</code></pre> <p>Warning</p> <p>It is worth noting that if the instruction is going to interrupt, the CPU RTL should also assert <code>debug_commit</code> to tell the SoC-Simulator that this instruction is retired even though it will not commit the GPR, and we should NOT assert <code>debug_wb_rf_wen</code> though the this instruction will not commit to GPR.</p> <p>And the CPU RTL should NOT assert the <code>debug_wb_rf_wen</code> and <code>debug_commit</code> during pipeline stall.</p> <p>Warning</p> <p>Additionally, SoC-Simulator also support commit GPR on both the rising and falling edges of the clock signal, which is <code>both_edge_commit</code> defines in <code>sim_mycpu.cpp</code>, it will be convient for superscalar CPU which commit width is 2.</p> <p>If your CPU does not support it, you should manually turn off it by replace <code>bool both_edge_commit = true;</code> with <code>bool both_edge_commit = false;</code>.</p>"},{"location":"mips/difftest-nscscc/#get-soc-simulator-and-running","title":"Get SoC-Simulator and Running","text":"<p>Assume you are in a folder like this:</p> <pre><code>.\n\u251c\u2500\u2500 linux\n\u251c\u2500\u2500 nscscc-group # You can get from nscscc.com\n\u251c\u2500\u2500 supervisor-mips32 # \n\u251c\u2500\u2500 u-boot # you can get from `git clone\n\u2514\u2500\u2500 ucore-thumips # compiled in setup.md\n</code></pre> <p>How to get these subfolders:</p> <ul> <li>linux: build from setup.md</li> <li>ucore-thumips: build from setup.md</li> <li>nscscc-group: From NSCSCC 2022 group package (www.nscscc.com)</li> <li>supervisor-mips32     <pre><code>git clone https://github.com/cyyself/supervisor-mips32.git -b nscscc\ncd supervisor-mips32/kernel\nmake GCCPREFIX=mipsel-unknown-linux-gnu- -j `nproc`\n</code></pre></li> <li>u-boot     <pre><code>git clone https://github.com/cyyself/u-boot.git -b cdim_soc\ncd u-boot\nmake ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-gnu- cdim_defconfig\nmake ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-gnu- -j `nproc`\n</code></pre></li> </ul> <p>Then, get soc-simulator:</p> <pre><code>git clone https://github.com/cyyself/soc-simulator.git\ncd soc-simulator\nbash ./scripts/init_cdim.sh\n# If you dont want CDIM, you can use\n# bash ./scripts/init_nscscc.sh\n# Then, change the CPU source file path in Makefile\n</code></pre>"},{"location":"mips/difftest-nscscc/#running-arguments","title":"Running Arguments","text":""},{"location":"mips/difftest-nscscc/#running-mode","title":"Running Mode","text":"<ul> <li><code>-func</code> NSCSCC Functional Test</li> <li><code>-perf</code> NSCSCC Performance Test</li> <li> <p><code>-sys</code>  NSCSCC System Test</p> <p>Note: You may need <code>socat</code> or <code>nc</code> to convert stdio to TCP socket. Example: <pre><code>socat tcp-listen:6666,reuseaddr exec:'./obj_dir/Vmycpu_top -sys' &amp;\ncd ../supervisor-mips32/term/\nGCCPREFIX=mipsel-unknown-linux-gnu- python3 term.py -t 127.0.0.1:6666\n</code></pre></p> </li> <li> <p><code>-linux</code> Run Linux</p> </li> <li><code>-ucore</code> Run uCore</li> <li><code>-uboot</code> Run U-Boot</li> </ul>"},{"location":"mips/difftest-nscscc/#arguments","title":"Arguments","text":"<ul> <li> <p><code>-axifast</code> Turn off AXI Latency</p> <p>We have explored the latency to approach the performance test.</p> <p>Turning it off will not significantly improve performance if your CPU has a Cache.</p> </li> <li> <p><code>-nodiff</code> Turn off diffential Test.</p> <p>It will be useful when your CPU behavior at the ISA level is different from CEMU but acceptable, you can check the behaviors of software in this mode.</p> </li> <li> <p><code>-trace [time]</code> Turn on trace at start and set the trace time (in ticks, which is double of cycles).</p> </li> <li> <p><code>-starttrace [time]</code> Set trace start time.</p> <p>By default, it will recode the waveform from this time to this time + 1000 ticks.</p> </li> <li> <p><code>-pc</code> Print PC every time.</p> </li> <li> <p><code>-diffmem</code> Differential Test AXI Memory Write (For Cache Debug).</p> </li> </ul> <p>Note</p> <p>All the waveforms will be saved to <code>trace.fst</code>.</p>"},{"location":"mips/difftest-nscscc/#arguments-for-performance-test-only","title":"Arguments for Performance Test Only","text":"<ul> <li> <p><code>-perfonce</code>: Run every performance test only once.</p> <p>Every test will run for 10 times by default.</p> </li> <li> <p><code>-uart</code>: Output confreg UART</p> <p>You will see how the performance test is going.</p> </li> <li> <p><code>-diffuart</code>: Differential Test confreg UART</p> <p>For MMIO Debug.</p> </li> <li> <p><code>-stat</code>: Output statistic result</p> </li> </ul>"},{"location":"mips/difftest-nscscc/#keyboard-function-when-running-mode-is-not-func-and-perf","title":"Keyboard function when running mode is not func and perf","text":"<ul> <li> <p><code>Ctrl</code> + <code>i</code>: Print Current PC (Program Counter)</p> </li> <li> <p><code>Ctrl</code> + <code>t</code>: recode waveform from current time to current time + 1000 ticks.</p> </li> </ul>"},{"location":"mips/difftest-nscscc/#example","title":"Example","text":"<ul> <li>Linux run with differential test:</li> </ul> <pre><code>./obj_dir/Vmycpu_top -linux\n[    0.000000] Linux version 6.3.0-13467-g63f399f0f695-dirty (cyy@cyy-pc) (mipsel-unknown-linux-gnu-gcc (crosstool-NG 1.25.0.166_9433647) 12.2.0, GNU ld (crosstool-NG 1.25.0.166_9433647) 2.40) #25 Mon May 15 00:25:31 CST 2023\n[    0.000000] printk: bootconsole [early0] enabled\n[    0.000000] CPU0 revision is: 00018003 (MIPS 4Kc)\n[    0.000000] MIPS: machine is nscscc,CQU_Dual_Issue_Machine\n[    0.000000] earlycon: ns16550a0 at MMIO 0x1fe40000 (options '')\n[    0.000000] printk: bootconsole [ns16550a0] enabled\n[    0.000000] Initrd not found or empty - disabling initrd\n[    0.000000] Primary instruction cache 8kB, VIPT, 2-way, linesize 64 bytes.\n[    0.000000] Primary data cache 8kB, 2-way, VIPT, no aliases, linesize 64 bytes\n[    0.000000] Zone ranges:\n[    0.000000]   Normal   [mem 0x0000000000000000-0x0000000007ffffff]\n[    0.000000] Movable zone start for each node\n[    0.000000] Early memory node ranges\n[    0.000000]   node   0: [mem 0x0000000000000000-0x0000000007ffffff]\n[    0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x0000000007ffffff]\n[    0.000000] Kernel command line: console=ttyS0,115200n8 rdinit=/sbin/init earlycon\n[    0.000000] Dentry cache hash table entries: 16384 (order: 4, 65536 bytes, linear)\n[    0.000000] Inode-cache hash table entries: 8192 (order: 3, 32768 bytes, linear)\n[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 32480\n[    0.000000] mem auto-init: stack:all(zero), heap alloc:off, heap free:off\n[    0.000000] Memory: 117968K/131072K available (7347K kernel code, 620K rwdata, 1124K rodata, 2484K init, 216K bss, 13104K reserved, 0K cma-reserved)\n[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\n[    0.000000] NR_IRQS: 256\n[    0.000000] arch_init_irq with ebase: 0x80000000\n[    0.000000] clocksource: MIPS: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 57337813970 ns\n[    0.000022] sched_clock: 32 bits at 33MHz, resolution 30ns, wraps every 64424509936ns\n[    0.002330] Console: colour dummy device 80x25\n[    0.003456] Calibrating delay loop... 65.79 BogoMIPS (lpj=131584)\n[    0.045612] pid_max: default: 32768 minimum: 301\n[    0.050073] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.050854] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.084261] cblist_init_generic: Setting adjustable number of callback queues.\n[    0.084859] cblist_init_generic: Setting shift to 0 and lim to 1.\n[    0.097443] devtmpfs: initialized\n[    0.132962] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns\n[    0.134126] futex hash table entries: 256 (order: -1, 3072 bytes, linear)\n[    0.158071] NET: Registered PF_NETLINK/PF_ROUTE protocol family\n[    0.227071] SCSI subsystem initialized\n[    0.232633] pps_core: LinuxPPS API ver. 1 registered\n[    0.233502] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;\n[    0.234564] PTP clock support registered\n[    0.251011] clocksource: Switched to clocksource MIPS\n[    0.527496] NET: Registered PF_INET protocol family\n[    0.532125] IP idents hash table entries: 2048 (order: 2, 16384 bytes, linear)\n[    0.541770] tcp_listen_portaddr_hash hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.542758] Table-perturb hash table entries: 65536 (order: 6, 262144 bytes, linear)\n[    0.543920] TCP established hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.544806] TCP bind hash table entries: 1024 (order: 1, 8192 bytes, linear)\n[    0.545774] TCP: Hash tables configured (established 1024 bind 1024)\n[    0.547945] UDP hash table entries: 256 (order: 0, 4096 bytes, linear)\n[    0.548856] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes, linear)\n[    0.552318] NET: Registered PF_UNIX/PF_LOCAL protocol family\n[    0.561463] RPC: Registered named UNIX socket transport module.\n[    0.562018] RPC: Registered udp transport module.\n[    0.562506] RPC: Registered tcp transport module.\n[    0.563332] RPC: Registered tcp NFSv4.1 backchannel transport module.\n[    0.597632] workingset: timestamp_bits=14 max_order=15 bucket_order=1\n[    0.642610] NFS: Registering the id_resolver key type\n[    0.644141] Key type id_resolver registered\n[    0.644644] Key type id_legacy registered\n[    0.645673] nfs4filelayout_init: NFSv4 File Layout Driver Registering...\n[    0.646263] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...\n[    0.647589] fuse: init (API version 7.38)\n[    0.677156] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 252)\n[    0.677799] io scheduler mq-deadline registered\n[    0.678312] io scheduler kyber registered\n[    3.392578] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled\n[    3.455389] printk: console [ttyS0] disabled\n[    3.456242] 1fe40000.serial: ttyS0 at MMIO 0x1fe40000 (irq = 3, base_baud = 6250000) is a 16550A\n[    3.457318] printk: console [ttyS0] enabled\n[    3.457318] printk: console [ttyS0] enabled\n[    3.458046] printk: bootconsole [early0] disabled\n[    3.458046] printk: bootconsole [early0] disabled\n[    3.459564] printk: bootconsole [ns16550a0] disabled\n[    3.459564] printk: bootconsole [ns16550a0] disabled\n[    3.526708] NET: Registered PF_INET6 protocol family\n[    3.594829] Segment Routing with IPv6\n[    3.596981] In-situ OAM (IOAM) with IPv6\n[    3.598494] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver\n[    3.613067] NET: Registered PF_PACKET protocol family\n[    3.615350] Key type dns_resolver registered\n[    4.306439] Key type .fscrypt registered\n[    4.306856] Key type fscrypt-provisioning registered\n[    4.333894] clk: Disabling unused clocks\n[    4.944821] Freeing unused kernel image (initmem) memory: 2484K\n[    4.945250] This architecture does not have kernel memory protection.\n[    4.945665] Run /sbin/init as init process\n\nPlease press Enter to activate this console. \n~ # \n</code></pre> <ul> <li>Linux run without differential test without AXI latency:</li> </ul> <pre><code>./obj_dir/Vmycpu_top -linux -nodiff -axifast\n</code></pre> <p>You will get the same output as above but different in times because of AXI latency, you will get about 40% performance improvement compared to above.</p> <ul> <li>Performance Test</li> </ul> <pre><code>./obj_dir/Vmycpu_top -perf          \n1b654\nbefbc\n1e1b06\n15160f\n44dc7\nccd6a\nd570f\nbc871\nd7f9\n9a10e\ntotal ticks = 30948883\n</code></pre> <p>Direct copy these lines to <code>IPC score calculation sheet</code> from nscscc final packge, you will get IPC score.</p> <ul> <li>Performance Test with statistics</li> </ul> <pre><code>./obj_dir/Vmycpu_top -perf -stat    \n1b654\ntotal_clk = 231658, stall_clk = 12545, has_commit = 198308, dual_commit = 131665, dual_issue_rate = 0.66394, IPC = 1.42440\nconfreg_read: 28, confreg_write: 502\nbefbc\ntotal_clk = 1571488, stall_clk = 88514, has_commit = 1115394, dual_commit = 593678, dual_issue_rate = 0.53226, IPC = 1.08755\nconfreg_read: 8, confreg_write: 156\n1e1b06\ntotal_clk = 3952382, stall_clk = 608646, has_commit = 2581866, dual_commit = 1511853, dual_issue_rate = 0.58557, IPC = 1.03576\nconfreg_read: 28, confreg_write: 7915\n15160f\ntotal_clk = 2769825, stall_clk = 232059, has_commit = 1615358, dual_commit = 947307, dual_issue_rate = 0.58644, IPC = 0.92521\nconfreg_read: 8, confreg_write: 9592\n44dc7\ntotal_clk = 570600, stall_clk = 109159, has_commit = 341275, dual_commit = 147268, dual_issue_rate = 0.43152, IPC = 0.85619\nconfreg_read: 28, confreg_write: 17902\nccd6a\ntotal_clk = 1685304, stall_clk = 164488, has_commit = 1177940, dual_commit = 535953, dual_issue_rate = 0.45499, IPC = 1.01696\nconfreg_read: 8, confreg_write: 152\nd570f\ntotal_clk = 1755581, stall_clk = 44135, has_commit = 1195724, dual_commit = 585725, dual_issue_rate = 0.48985, IPC = 1.01473\nconfreg_read: 8, confreg_write: 156\nbc871\ntotal_clk = 1550455, stall_clk = 83471, has_commit = 1094799, dual_commit = 657087, dual_issue_rate = 0.60019, IPC = 1.12992\nconfreg_read: 8, confreg_write: 2214\nd7f9\ntotal_clk = 117860, stall_clk = 10504, has_commit = 74013, dual_commit = 43755, dual_issue_rate = 0.59118, IPC = 0.99922\nconfreg_read: 8, confreg_write: 154\n9a10e\ntotal_clk = 1269288, stall_clk = 147152, has_commit = 857688, dual_commit = 331955, dual_issue_rate = 0.38703, IPC = 0.93725\nconfreg_read: 8, confreg_write: 32134\ntotal ticks = 30948883\n</code></pre> <ul> <li>Function Test</li> </ul> <pre><code>./obj_dir/Vmycpu_top -func                  \nNumber 1 Functional Test Point PASS!\nNumber 2 Functional Test Point PASS!\nNumber 3 Functional Test Point PASS!\nNumber 4 Functional Test Point PASS!\nNumber 5 Functional Test Point PASS!\nNumber 6 Functional Test Point PASS!\nNumber 7 Functional Test Point PASS!\nNumber 8 Functional Test Point PASS!\nNumber 9 Functional Test Point PASS!\nNumber 10 Functional Test Point PASS!\nNumber 11 Functional Test Point PASS!\nNumber 12 Functional Test Point PASS!\nNumber 13 Functional Test Point PASS!\nNumber 14 Functional Test Point PASS!\nNumber 15 Functional Test Point PASS!\nNumber 16 Functional Test Point PASS!\nNumber 17 Functional Test Point PASS!\nNumber 18 Functional Test Point PASS!\nNumber 19 Functional Test Point PASS!\nNumber 20 Functional Test Point PASS!\nNumber 21 Functional Test Point PASS!\nNumber 22 Functional Test Point PASS!\nNumber 23 Functional Test Point PASS!\nNumber 24 Functional Test Point PASS!\nNumber 25 Functional Test Point PASS!\nNumber 26 Functional Test Point PASS!\nNumber 27 Functional Test Point PASS!\nNumber 28 Functional Test Point PASS!\nNumber 29 Functional Test Point PASS!\nNumber 30 Functional Test Point PASS!\nNumber 31 Functional Test Point PASS!\nNumber 32 Functional Test Point PASS!\nNumber 33 Functional Test Point PASS!\nNumber 34 Functional Test Point PASS!\nNumber 35 Functional Test Point PASS!\nNumber 36 Functional Test Point PASS!\nNumber 37 Functional Test Point PASS!\nNumber 38 Functional Test Point PASS!\nNumber 39 Functional Test Point PASS!\nNumber 40 Functional Test Point PASS!\nNumber 41 Functional Test Point PASS!\nNumber 42 Functional Test Point PASS!\nNumber 43 Functional Test Point PASS!\nNumber 44 Functional Test Point PASS!\nNumber 45 Functional Test Point PASS!\nNumber 46 Functional Test Point PASS!\nNumber 47 Functional Test Point PASS!\nNumber 48 Functional Test Point PASS!\nNumber 49 Functional Test Point PASS!\nNumber 50 Functional Test Point PASS!\nNumber 51 Functional Test Point PASS!\nNumber 52 Functional Test Point PASS!\nNumber 53 Functional Test Point PASS!\nNumber 54 Functional Test Point PASS!\nNumber 55 Functional Test Point PASS!\nNumber 56 Functional Test Point PASS!\nNumber 57 Functional Test Point PASS!\nNumber 58 Functional Test Point PASS!\nNumber 59 Functional Test Point PASS!\nNumber 60 Functional Test Point PASS!\nNumber 61 Functional Test Point PASS!\nNumber 62 Functional Test Point PASS!\nNumber 63 Functional Test Point PASS!\nNumber 64 Functional Test Point PASS!\nNumber 65 Functional Test Point PASS!\nNumber 66 Functional Test Point PASS!\nNumber 67 Functional Test Point PASS!\nNumber 68 Functional Test Point PASS!\nNumber 69 Functional Test Point PASS!\nNumber 70 Functional Test Point PASS!\nNumber 71 Functional Test Point PASS!\nNumber 72 Functional Test Point PASS!\nNumber 73 Functional Test Point PASS!\nNumber 74 Functional Test Point PASS!\nNumber 75 Functional Test Point PASS!\nNumber 76 Functional Test Point PASS!\nNumber 77 Functional Test Point PASS!\nNumber 78 Functional Test Point PASS!\nNumber 79 Functional Test Point PASS!\nNumber 80 Functional Test Point PASS!\nNumber 81 Functional Test Point PASS!\nNumber 82 Functional Test Point PASS!\nNumber 83 Functional Test Point PASS!\nNumber 84 Functional Test Point PASS!\nNumber 85 Functional Test Point PASS!\nNumber 86 Functional Test Point PASS!\nNumber 87 Functional Test Point PASS!\nNumber 88 Functional Test Point PASS!\nNumber 89 Functional Test Point PASS!\n</code></pre>"},{"location":"mips/setup/","title":"MIPS Setup","text":""},{"location":"mips/setup/#build-cross-compile-toolchains","title":"Build cross-compile Toolchains","text":"<p>We recommand use crosstool-NG.</p> <pre><code>git clone https://github.com/crosstool-ng/crosstool-ng\npushd crosstool-ng\n    ./bootstrap\n    sudo mkdir /opt/ct-ng\n    sudo chown -R $USER /opt/ct-ng\n    ./configure --prefix=/opt/ct-ng\n    make -j `nproc`\nmake install\n    export PATH=/opt/ct-ng/bin:$PATH\npopd\nsudo mkdir /opt/mips32\nsudo chown -R $USER /opt/mips32\npushd /opt/mips32\n    ct-ng mipsel-unknown-linux-gnu\n    sed -i 's/CT_ARCH_ARCH=\"mips1\"/CT_ARCH_ARCH=\"mips32\"/g' .config\n    ct-ng build\n    # Now, toolchains available at `/opt/mips32/.build/mipsel-unknown-linux-gnu/buildtools/bin`\necho \"export PATH=$HOME/x-tools/mipsel-unknown-linux-gnu/bin:\\$PATH\" &gt;&gt; ~/.bashrc\n    source ~/.bashrc\n    # Replace .bashrc if you are using some shells other than bash, such as .zshrc for zsh.\npopd\n</code></pre>"},{"location":"mips/setup/#ucore-boot","title":"uCore boot","text":"<pre><code>git clone https://github.com/cyyself/ucore-thumips.git\npushd ucore-thumips\n    make GCCPREFIX=mipsel-unknown-linux-gnu-\npopd\ngit clone https://github.com/cyyself/cemu.git\npushd cemu\n</code></pre> <p>Save the following file to <code>cemu/src/main.cpp</code></p> src/main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;thread&gt;\n#include &lt;termios.h&gt;\n#include &lt;cassert&gt;\n#include &lt;unistd.h&gt;\n#include &lt;csignal&gt;\n#include &lt;fcntl.h&gt;\n\n#include \"mips_core.hpp\"\n#include \"nscscc_confreg.hpp\"\n#include \"memory_bus.hpp\"\n#include \"ram.hpp\"\n#include \"uart8250.hpp\"\n\nvoid uart_input(uart8250 &amp;uart) {\ntermios tmp;\ntcgetattr(STDIN_FILENO,&amp;tmp);\ntmp.c_lflag &amp;=(~ICANON &amp; ~ECHO);\ntcsetattr(STDIN_FILENO,TCSANOW,&amp;tmp);\nwhile (true) {\nchar c = getchar();\nif (c == 10) c = 13; // convert lf to cr\nuart.putc(c);\n}\n}\n\nbool send_ctrl_c;\n\nvoid sigint_handler(int x) {\nstatic time_t last_time;\nif (time(NULL) - last_time &lt; 1) exit(0);\nlast_time = time(NULL);\nsend_ctrl_c = true;\n}\n\nvoid ucore_run(int argc, const char* argv[]) {\nsignal(SIGINT, sigint_handler);\n\nmemory_bus cemu_mmio;\n\nram cemu_memory(128*1024*1024, \"../ucore-thumips/obj/ucore-kernel-initrd.bin\");\nassert(cemu_mmio.add_dev(0,128*1024*1024,&amp;cemu_memory));\n\n// uart8250 at 0x1fe40000 (APB)\nuart8250 uart;\nstd::thread *uart_input_thread = new std::thread(uart_input,std::ref(uart));\nassert(cemu_mmio.add_dev(0x1fe40000,0x10000,&amp;uart));\n\nmips_core mips(cemu_mmio);\nmips.jump(0x80000000u);\nuint32_t lastpc = 0;\nbool delay_cr = false;\nwhile (true) {\nmips.step(uart.irq() &lt;&lt; 1);\nwhile (uart.exist_tx()) {\nchar c = uart.getc();\nif (c == '\\r') delay_cr = true;\nelse {\nif (delay_cr &amp;&amp; c != '\\n') std::cout &lt;&lt; \"\\r\" &lt;&lt; c;\nelse std::cout &lt;&lt; c;\nstd::cout.flush();\ndelay_cr = false;\n}\n}\nif (send_ctrl_c) {\nuart.putc(3);\nsend_ctrl_c = false;\n}\n}\n}\n\nint main(int argc, const char* argv[]) {\nucore_run(argc, argv);\nreturn 0;\n}\n</code></pre> <pre><code># at cemu project folder\nmake\n./cemu\n++setup timer interrupts\nInitrd: 0x8006aa50 - 0x800c224f, size: 0x00057800, magic: 0x2f8dbe2a\n(THU.CST) os is loading ...\n\nSpecial kernel symbols:\n  entry  0x80000108 (phys)\n  etext 0x8002B400 (phys)\n  edata 0x800C2250 (phys)\n  end   0x800C5570 (phys)\nKernel executable memory footprint: 617KB\nmemory management: buddy_pmm_manager\nmemory map:\n    [80000000, 82000000]\n\nfreemem start at: 80106000\nfree pages: 00001EFA\n## 00000020\ncheck_alloc_page() succeeded!\ncheck_pgdir() succeeded!\ncheck_boot_pgdir() succeeded!\n-------------------- BEGIN --------------------\n--------------------- END ---------------------\ncheck_slab() succeeded!\nkmalloc_init() succeeded!\ncheck_vma_struct() succeeded!\ncheck_pgfault() succeeded!\ncheck_vmm() succeeded.\nsched class: RR_scheduler\nramdisk_init(): initrd found, magic: 0x2f8dbe2a, 0x000002bc secs\nsfs: mount: 'simple file system' (81/6/87)\nvfs: mount disk0.\nkernel_execve: pid = 2, name = \"sh\".\nuser sh is running!!!\n$ \n</code></pre>"},{"location":"mips/setup/#linux-boot","title":"Linux boot","text":""},{"location":"mips/setup/#build-busybox-and-prepare-rootfs","title":"Build Busybox and prepare rootfs","text":"<pre><code>git clone https://github.com/mirror/busybox.git\npushd busybox\n    make ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-gnu- defconfig\n    sed -i 's/# CONFIG_STATIC is not set/CONFIG_STATIC=y/g' .config\n    # Note: If you don't want static build, you need to copy the entire ~/x-tools/mipsel-unknown-linux-gnu/mipsel-unknown-linux-gnu/sysroot/ to your rootfs, it will be too huge for initrd by default\nmake -j `nproc`\nmake install\npopd busybox\nmkdir rootfs\npushd rootfs\n    sudo rsync -ar ../busybox/_install/* .\n    sudo chown root:root * -R\n    sudo mkdir -p proc sys dev etc/init.d\n    sudo mknod -m 622 dev/console c 5 1\nsudo mknod -m 666 dev/null c 1 3\nsudo mknod -m 666 dev/zero c 1 5\nsudo mknod -m 666 dev/ptmx c 5 2\nsudo mknod -m 666 dev/tty c 5 0\nsudo mknod -m 444 dev/random c 1 8\nsudo mknod -m 444 dev/urandom c 1 9\nsudo chown root:tty dev/{console,ptmx,tty}\nsudo sh -c 'echo \"#!/bin/sh\\nmount -t proc none /proc\\nmount -t sysfs none /sys\\nln -s /dev/null /dev/tty2\\nln -s /dev/null /dev/tty3\\nln -s /dev/null /dev/tty4\\nexit 0\" &gt; etc/init.d/rcS'\nsudo chmod a+x etc/init.d/rcS\npopd\n</code></pre>"},{"location":"mips/setup/#build-linux-kernel","title":"Build Linux Kernel","text":"<pre><code>git clone https://github.com/cyyself/linux.git -b cdim_soc\npushd linux\n    make ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-gnu- cdim_defconfig\n    # Disable axi intc and axi emaclite in device-tree\nsed -i 's/status = \"okay\"/status = \"disabled\"/g' arch/mips/boot/dts/nscscc/cdim.dts\n    make ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-gnu- -j `nproc`\nmipsel-unknown-linux-gnu-objcopy -O binary vmlinux vmlinux.bin\npopd\ngit clone https://github.com/cyyself/cemu.git\npushd cemu\n</code></pre> <p>Save the following file to <code>cemu/src/main.cpp</code></p> src/main.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;thread&gt;\n#include &lt;termios.h&gt;\n#include &lt;cassert&gt;\n#include &lt;unistd.h&gt;\n#include &lt;csignal&gt;\n#include &lt;fcntl.h&gt;\n\n#include \"mips_core.hpp\"\n#include \"nscscc_confreg.hpp\"\n#include \"memory_bus.hpp\"\n#include \"ram.hpp\"\n#include \"uart8250.hpp\"\n\nvoid uart_input(uart8250 &amp;uart) {\ntermios tmp;\ntcgetattr(STDIN_FILENO,&amp;tmp);\ntmp.c_lflag &amp;=(~ICANON &amp; ~ECHO);\ntcsetattr(STDIN_FILENO,TCSANOW,&amp;tmp);\nwhile (true) {\nchar c = getchar();\nif (c == 10) c = 13; // convert lf to cr\nuart.putc(c);\n}\n}\n\nbool send_ctrl_c;\n\nvoid sigint_handler(int x) {\nstatic time_t last_time;\nif (time(NULL) - last_time &lt; 1) exit(0);\nlast_time = time(NULL);\nsend_ctrl_c = true;\n}\n\nvoid linux_run(int argc, const char* argv[]) {\nsignal(SIGINT, sigint_handler);\n\nmemory_bus cemu_mmio;\n\nram cemu_memory(128*1024*1024);\ncemu_memory.load_binary(0x100000, \"../linux/vmlinux.bin\");\nassert(cemu_mmio.add_dev(0,128*1024*1024,&amp;cemu_memory));\n\n// uart8250 at 0x1fe40000 (APB)\nuart8250 uart;\nstd::thread *uart_input_thread = new std::thread(uart_input,std::ref(uart));\nassert(cemu_mmio.add_dev(0x1fe40000,0x10000,&amp;uart));\n\nmips_core mips(cemu_mmio);\nmips.jump(0x80100000u);\nuint32_t lastpc = 0;\nbool delay_cr = false;\nwhile (true) {\nmips.step(uart.irq() &lt;&lt; 1);\nwhile (uart.exist_tx()) {\nchar c = uart.getc();\nif (c == '\\r') delay_cr = true;\nelse {\nif (delay_cr &amp;&amp; c != '\\n') std::cout &lt;&lt; \"\\r\" &lt;&lt; c;\nelse std::cout &lt;&lt; c;\nstd::cout.flush();\ndelay_cr = false;\n}\n}\nif (send_ctrl_c) {\nuart.putc(3);\nsend_ctrl_c = false;\n}\n}\n}\n\nint main(int argc, const char* argv[]) {\nlinux_run(argc, argv);\nreturn 0;\n}\n</code></pre> <pre><code># at cemu project folder\nmake\n./cemu                                                                             \n[    0.000000] Linux version 6.3.0-13467-g75fb980ad88e-dirty (cyy@cyy-pc) (mipsel-unknown-linux-gnu-gcc (crosstool-NG 1.25.0.166_9433647) 12.2.0, GNU ld (crosstool-NG 1.25.0.166_9433647) 2.40) #16 Mon May  8 00:56:24 CST 2023\n[    0.000000] printk: bootconsole [early0] enabled\n[    0.000000] CPU0 revision is: 00018003 (MIPS 4Kc)\n[    0.000000] MIPS: machine is nscscc,CQU_Dual_Issue_Machine\n[    0.000000] Malformed early option 'earlycon'\n[    0.000000] Initrd not found or empty - disabling initrd\n[    0.000000] Primary instruction cache 8kB, VIPT, 2-way, linesize 64 bytes.\n[    0.000000] Primary data cache 8kB, 2-way, VIPT, no aliases, linesize 64 bytes\n[    0.000000] Zone ranges:\n[    0.000000]   Normal   [mem 0x0000000000000000-0x0000000007ffffff]\n[    0.000000] Movable zone start for each node\n[    0.000000] Early memory node ranges\n[    0.000000]   node   0: [mem 0x0000000000000000-0x0000000007ffffff]\n[    0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x0000000007ffffff]\n[    0.000000] Kernel command line: console=ttyS0,115200n8 rdinit=/sbin/init earlycon\n[    0.000000] Dentry cache hash table entries: 16384 (order: 4, 65536 bytes, linear)\n[    0.000000] Inode-cache hash table entries: 8192 (order: 3, 32768 bytes, linear)\n[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 32480\n[    0.000000] mem auto-init: stack:all(zero), heap alloc:off, heap free:off\n[    0.000000] Memory: 118096K/131072K available (7257K kernel code, 610K rwdata, 1096K rodata, 2484K init, 216K bss, 12976K reserved, 0K cma-reserved)\n[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\n[    0.000000] NR_IRQS: 256\n[    0.000000] arch_init_irq with ebase: 0x80000000\n[    0.000000] clocksource: MIPS: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 57337813970 ns\n[    0.000009] sched_clock: 32 bits at 33MHz, resolution 30ns, wraps every 64424509936ns\n[    0.002404] Console: colour dummy device 80x25\n[    0.002804] Calibrating delay loop... 33.15 BogoMIPS (lpj=66304)\n[    0.052502] pid_max: default: 32768 minimum: 301\n[    0.054988] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.055391] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.073476] cblist_init_generic: Setting adjustable number of callback queues.\n[    0.073746] cblist_init_generic: Setting shift to 0 and lim to 1.\n[    0.080127] devtmpfs: initialized\n[    0.097662] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns\n[    0.098119] futex hash table entries: 256 (order: -1, 3072 bytes, linear)\n[    0.117142] NET: Registered PF_NETLINK/PF_ROUTE protocol family\n[    0.155162] SCSI subsystem initialized\n[    0.167799] clocksource: Switched to clocksource MIPS\n[    0.306714] NET: Registered PF_INET protocol family\n[    0.310480] IP idents hash table entries: 2048 (order: 2, 16384 bytes, linear)\n[    0.323866] tcp_listen_portaddr_hash hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.324632] Table-perturb hash table entries: 65536 (order: 6, 262144 bytes, linear)\n[    0.325076] TCP established hash table entries: 1024 (order: 0, 4096 bytes, linear)\n[    0.325755] TCP bind hash table entries: 1024 (order: 1, 8192 bytes, linear)\n[    0.326501] TCP: Hash tables configured (established 1024 bind 1024)\n[    0.327416] UDP hash table entries: 256 (order: 0, 4096 bytes, linear)\n[    0.328059] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes, linear)\n[    0.329948] NET: Registered PF_UNIX/PF_LOCAL protocol family\n[    0.334508] RPC: Registered named UNIX socket transport module.\n[    0.334752] RPC: Registered udp transport module.\n[    0.334971] RPC: Registered tcp transport module.\n[    0.335190] RPC: Registered tcp NFSv4.1 backchannel transport module.\n[    0.364317] workingset: timestamp_bits=14 max_order=15 bucket_order=1\n[    0.374149] NFS: Registering the id_resolver key type\n[    0.374893] Key type id_resolver registered\n[    0.375109] Key type id_legacy registered\n[    0.375614] nfs4filelayout_init: NFSv4 File Layout Driver Registering...\n[    0.375983] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...\n[    0.376492] fuse: init (API version 7.38)\n[    0.383223] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)\n[    0.383516] io scheduler mq-deadline registered\n[    0.383750] io scheduler kyber registered\n[    1.693393] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled\n[    1.734751] printk: console [ttyS0] disabled\n[    1.735135] 1fe40000.serial: ttyS0 at MMIO 0x1fe40000 (irq = 3, base_baud = 6250000) is a 16550A\n[    1.735707] printk: console [ttyS0] enabled\n[    1.735707] printk: console [ttyS0] enabled\n[    1.736247] printk: bootconsole [early0] disabled\n[    1.736247] printk: bootconsole [early0] disabled\n[    1.753251] NET: Registered PF_INET6 protocol family\n[    1.789533] Segment Routing with IPv6\n[    1.791205] In-situ OAM (IOAM) with IPv6\n[    1.792675] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver\n[    1.801848] NET: Registered PF_PACKET protocol family\n[    1.803474] Key type dns_resolver registered\n[    2.182276] Key type .fscrypt registered\n[    2.182572] Key type fscrypt-provisioning registered\n[    2.193653] clk: Disabling unused clocks\n[    3.596393] Freeing unused kernel image (initmem) memory: 2484K\n[    3.596670] This architecture does not have kernel memory protection.\n[    3.596976] Run /sbin/init as init process\n\nPlease press Enter to activate this console. \n~ # \n</code></pre>"}]}